#!/bin/bash

version=3.2.10

prog=`readlink $0 2>/dev/null`
[[ -z $prog ]] && prog=$0
path=`dirname $prog`
path=`cd "$path";pwd`

[ x$BITSENV_DEBUG == x1 ] && printf "path=$path\nprog=$prog\n" >&2

path=$(cd $(dirname $0) && pwd) # appended to PATH later on

printvar=""

# If using modulecmd from the system, and ver >= 4, this var enables 3.x compat mode
export MODULES_USE_COMPAT_VERSION=1

Eval(){
   cmd=$*
   ret=`$cmd` || return 1
   [ -z "$ret" ] && return 0
   eval $ret
}

os_release=/etc/os-release

which lsb_release > /dev/null 2>&1

if [[ $? == 0 ]] ; then
  distro_name=`lsb_release -i | sed -e 's/.*://' -e 's/[ \t]*//g'`
  distro_release=`lsb_release -r | awk '{print $NF}'`
elif [[ -r "$os_release" ]] ; then
  distro_name=`source "$os_release" ; echo $NAME`
  distro_release=`source "$os_release" ; echo $VERSION_ID`
else
  distro_name='<unknown>'
  distro_release='<unknown>'
fi

[ x$BITSENV_DEBUG == x1 ] && printf "distro_name=$distro_name\ndistro_release=$distro_release\n" >&2

case $distro_name in
     Scientific*|CentOS*|Rocky*|Alma*|RedHatEnterprise*|'Red Hat Enterprise'*)
        distro_dir="Scientific"
        uname_m=`uname -m`
        arch=${uname_m}-2.6-gnu-4.1.2
        case $distro_release in
           5.*)
              distro_xrelease=5.x
              platform=el5
              ;;
           6.*)
              distro_xrelease=6.x
              platform=el6
              ;;
           7*)
              distro_xrelease=6.x
              platform=el7
              ;;
           8*)
              distro_xrelease=8.x
              platform=el8
              ;;
           9*)
              distro_xrelease=8.x
              platform=el9
              ;;
        esac
        ;;
     Fedora*)
        distro_dir="Scientific"
        uname_m=`uname -m`
        arch=${uname_m}-2.6-gnu-4.1.2
        case $distro_release in
           17|18)
              distro_xrelease=6.x
              platform=el6
              ;;
           19|20|21)
              distro_xrelease=6.x
              platform=el7
              ;;
           *)
              distro_xrelease=6.x
              ;;
        esac
        ;;
     SUSE*)
        distro_dir="Scientific"
        uname_m=`uname -m`
        arch=${uname_m}-2.6-gnu-4.1.2
        case $distro_release in
           11) # Titan
              distro_xrelease=6.x
              platform=suse11
              ;;
           *)
              distro_xrelease=6.x
              ;;
        esac
        ;;
     Debian*)
        distro_dir="Scientific"
        uname_m=`uname -m`
        arch=${uname_m}-2.6-gnu-4.1.2
        case $distro_release in
           6.*|6|7.*|7)
              distro_xrelease=6.x
              ;;
           8.*|8)
              # Required from system: apt install libx11-6 environment-modules
              distro_xrelease=
              platform=ubuntu1404
              ;;
           9.*|9)
              # Required from system: apt install libx11-6 environment-modules
              distro_xrelease=
              platform=ubuntu1604
              ;;
        esac
        ;;
     Ubuntu*)
        distro_dir="Scientific"
        uname_m=`uname -m`
        arch=${uname_m}-2.6-gnu-4.1.2
        case $distro_release in
           13.*)
              distro_xrelease=6.x
              ;;
           14.*|15.*)
              distro_xrelease=6.x
              platform=ubuntu1404
              ;;
           16.*|17.*|18.*|2?.*)
              # Required from system: apt install libx11-6 environment-modules
              distro_xrelease=
              platform=ubuntu1604
              ;;
        esac
        ;;
     *)
      echo "Unknown distribution: $distro_name $distro_release"
      exit 1
     ;;
esac

[ -f .bitsenv ] && source .bitsenv

argc=$#
argv=("$@")

for (( j=0; j<argc; j++ ))
do
  case "${argv[j]}" in
     -m|-?modules|-?mdir|-?moduledir)
	 moduledir="${argv[j+1]}"
	 ;;
     -p|-?platform)
	 platform="${argv[j+1]}"
	 ;;
     *)
	 ;; 
   esac
done

if [ -z $moduledir ]
then
  if [[ "$BITS_MODULEDIR" != "" ]]; then
    moduledir="$BITS_MODULEDIR"
  elif [[ `basename $prog` == bitsenv && `basename $path` == bin ]]; then
    moduledir=`dirname "$path"`
  fi
fi

if [ -z $moduledir ]
then
   bits=`which bits`
   if [ ! -z $bits ]
   then
      exec $bits $@ 
   fi    
   printf "Could not determine module directory, please set BITS_MODULEDIR\n"
   exit 1
fi

[ x$BITSENV_DEBUG == x1 ] && printf "moduledir=$moduledir\n" >&2

[[ "$BITS_PLATFORM" != "" ]] && { printf "WARNING: overriding detected platform ($platform) with $BITS_PLATFORM\n" >&2; platform=$BITS_PLATFORM; }

[ x$BITSENV_DEBUG == x1 ] && printf "distro_dir=$distro_dir\nuname_m=$uname_m\narch=$arch\ndistro_xrelease=$distro_xrelease\nplatform=$platform\n" >&2

if [ -w . -a ! -f bits.rc -a  ! -f .bitsrc ]
then
   printf "moduledir=$moduledir\nplatform=$platform\n" > .bitsenv
fi

modules=$moduledir/$arch/Modules

if [  ! -d $modules ]
then
   echo "Platform $distro_dir,$arch not supported"
   exit 1
fi

unset MODULESHOME

function modulepath() {
  local dir
  local colon
  local subdir
  subdir=$1; shift 1
  for dir in $MODULEPATH $*
  do
    if [ -d $dir/Modules/$subdir ]
    then
       printf "${colon}${dir}/Modules/${subdir}"
       colon=":"
    fi
  done
  printf "\n"
}

function test_toolchain() {
  local TMPPREF=/tmp/bitsenv_helloworld
  cat > $TMPPREF.cpp <<EOF
#include <iostream>
int main(int argn, char *argv[]) {
  std::cout << "hello world" << std::endl;
  return 0;
}
EOF
  g++ -o $TMPPREF ${TMPPREF}.cpp > ${TMPPREF}.log 2>&1
  if [[ `/tmp/bitsenv_helloworld 2> /dev/null` != "hello world" ]]; then
    echo "WARNING: We are using GNU C++ compiler at $(which g++ 2> /dev/null)" >&2
    echo "WARNING: This compiler is unable to produce valid executables on this platform!" >&2
    echo "WARNING: Error from g++ follows:" >&2
    while IFS= read LINE; do
      echo "WARNING: $LINE" >&2
    done < <(cat ${TMPPREF}.log)
  else
    echo "NOTICE: loaded compiler ($(which g++)) seems to produce valid executables" >&2
  fi
  rm -f ${TMPPREF}*
}


# Transform a comma-separated packages to modulecmd
# format, i.e.:
#
# Returned list (on stdout) is also sorted: packages with a certain priority
# are moved at the beginning of the list.
function normalize_sort_packages() {
  NORM=( $(echo $1 | sed -e 's%::%/%g' -e 's%,% %g') )
  [[ $BITSENV_DEBUG == 1 ]] && printf "NOTICE: list of packages normalized to ${NORM[*]}\n" >&2
  echo ${NORM[*]}
}

export PATH=$PATH:$path

if [  -d $modules/$version/$distro_dir/$distro_release ]
then
   moduleenv="env LD_LIBRARY_PATH=$modules/$version/$distro_dir/$distro_release/lib"
   modulecmd="$modules/$version/$distro_dir/$distro_release/bin/modulecmd"
else
   moduleenv="env LD_LIBRARY_PATH=$modules/$version/$distro_dir/$distro_xrelease/lib"
   modulecmd="$modules/$version/$distro_dir/$distro_xrelease/bin/modulecmd"
fi

if [[ ! -f $modulecmd ]]; then
  # Fallback on system-installed
  [[ $BITSENV_DEBUG == 1 ]] && printf "NOTICE: using modulecmd from the system\n" >&2
  modulecmd=modulecmd
  moduleenv=
fi

[[ $BITSENV_DEBUG == 1 ]] && printf "modulecmd=$modulecmd\nmoduleenv=$moduleenv\n" >&2

T=`mktemp`

$moduleenv $modulecmd &> $T

if [[ $? == 127 ]]; then
      echo "Unknown distribution release: $distro_name $distro_release"
      [[ $BITSENV_DEBUG == 1 ]] && printf "ERROR: full error message is: `cat $T`\n" >&2
      rm -f $T
      exit 1
fi

rm -f $T
unset T

tclsh <<EOF >/dev/null 2>&1
EOF

[[ $? == 0 ]] && moduleenv=

command=""

# We cannot cross-pick pacakages among different platforms but we have to
# pick all packages consistently from a certain platform tree. When listing
# packages we show them all, when we load a package e define a priority list and
# we always have a fallback for backward compatibility.
ARGS=("$@")
PACKAGES=
EXPECT_PACKAGES=

for ARG in "$@"; do
  if [[ $EXPECT_PACKAGES == 1 ]]; then
    PACKAGES=$(normalize_sort_packages "$ARG")
    break
  elif [[ "$ARG" == enter || "$ARG" == printenv || "$ARG" == setenv || "$ARG" == checkenv ]]; then
    EXPECT_PACKAGES=1
  else
    EXPECT_PACKAGES=
  fi
done

export MODULEPATH="$moduledir/etc/toolchain/modulefiles/$platform-$uname_m:$moduledir/$platform-$uname_m/Modules/modulefiles"

[ x$BITSENV_DEBUG == x1 ] && printf "MODULEPATH=$MODULEPATH\n" >&2

COMMAND_IN_ENV=()

while [ $# -gt 0 ]
do
  case $1 in
     enter)
       shift 1
       args=$(normalize_sort_packages "$1")
       before=`printenv`
       Eval $moduleenv $modulecmd bash load $args 2>/dev/null || exit 1
       after=`printenv | grep -v LS_COLORS=`
       _LM_ENV=""
       for var in $after
       do
         if [[ ! "$before"  =~ "$var" ]]
         then
            _LM_ENV="$var;$_LM_ENV"
         fi
       done
       export _LM_ENV
       exec env PS1="[$args] \W > " bash --norc -i
       ;;
     setenv)
       shift 1
       args=$(normalize_sort_packages "$1")
       Eval $moduleenv $modulecmd bash load $args 2>/dev/null || exit 1
       shift 1
       ;;
     checkenv)
       shift 1
       args=$(normalize_sort_packages "$1")
       Eval $moduleenv $modulecmd bash load $args || exit 1
       PREV_PKG=
       PREV_VER=
       PKG_ERR=
       while read LMF; do
         VER=${LMF##*/}
         PKG=${LMF%/*}
         PKG=${PKG##*/}
         if [[ $PKG == $PREV_PKG && $VER != $PREV_VER ]]; then
           printf "ERROR: attempting to load $PKG $VER when conflicting version $PREV_VER already loaded\n" >&2
           PKG_ERR=1
         fi
         PREV_PKG=$PKG
         PREV_VER=$VER
       done < <(echo $_LMFILES_ | sed -e 's/:/\n/g' | sort)
       [[ $PKG_ERR ]] && exit 1
       [[ $BITSENV_DEBUG == 1 ]] && printf "NOTICE: all packages loaded successfully\n" >&2
       exit 0
       ;;
     printenv)
       shift 1
       if [ x$1 = x ]
       then
          echo $_LM_ENV
       fi
       args=$(normalize_sort_packages "$1")
       $moduleenv $modulecmd bash load $args 2>/dev/null
       exit
       ;;
     -m|-?modules|-?mdir|-?moduledir)
       shift 2
       ;;
     -p|-?platform)
       shift 2
       ;;
     -print)
       shift 1
       var=$1
       echo ${!var}
       shift 1
       ;;
     -a|--archive)
       shift 1
       export MODULEPATH=$MODULEPATH:$(modulepath archive $moduledirs)
       ;;
     -c)
       shift; COMMAND_IN_ENV=("$@");
       exec "${COMMAND_IN_ENV[@]}"
       ;;
     q|query)
       $moduleenv $modulecmd bash -t avail  2>&1 | grep -v -e : -e "^$"
       exit $?
       ;;
     *)
       $moduleenv $modulecmd bash $*
       exit
     ;;
    esac
done

