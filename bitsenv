#!/bin/bash


function Help() {
  cat<<EOF
  Usage: bitsenv [-m <modules directory>] [-p <platform>] [-h]
                 <checkenv|printenv|enter> <package/version>[,<package/version>...]
                 setenv> <package/version>[,<package/version>...] -c <command>
                 <query|q>
EOF
  exit 0 
}
    
version=3.2.10

prog=`readlink $0 2>/dev/null`
[[ -z $prog ]] && prog=$0
path=`dirname $prog`
path=`cd "$path";pwd`

[ x$BITSENV_DEBUG == x1 ] && printf "path=$path\nprog=$prog\n" >&2

path=$(cd $(dirname $0) && pwd) # appended to PATH later on

printvar=""

# If using modulecmd from the system, and ver >= 4, this var enables 3.x compat mode
export MODULES_USE_COMPAT_VERSION=1

Eval(){
   cmd=$*
   ret=`$cmd` || return 1
   [ -z "$ret" ] && return 0
   eval $ret
}

[ -f .bitsenv ] && source .bitsenv && [ x$BITSENV_DEBUG == x1 ] && printf "found .bitsenv"

argc=$#
argv=("$@")

for (( j=0; j<argc; j++ ))
do
  case "${argv[j]}" in
     -m|-?modules|-?mdir|-?moduledir)
	 moduledir="${argv[j+1]}"
	 ;;
     -p|-?platform)
	 platform="${argv[j+1]}"
	 ;;
     -h)
	 Help
	 ;;
     *)
	 ;; 
   esac
done

if [ -z $platform ]
then
    if [[ "$BITS_PLATFORM" != "" ]]
    then
	printf "WARNING: overriding detected platform ($platform) with $BITS_PLATFORM\n" >&2;
	platform=$BITS_PLATFORM;
    else
	platform=$(bits architecture)
    fi	
fi

if [ -z $moduledir ]
then
  if [[ "$BITS_MODULEDIR" != "" ]]; then
    moduledir="$BITS_MODULEDIR"
  elif [[ `basename $prog` == bitsenv && `basename $path` == bin ]]; then
    moduledir=`dirname "$path"`
  fi
fi

if [ -z $moduledir ]
then
   bits=`which bits`
   if [ ! -z $bits ]
   then
      exec $bits $@ 
   fi    
   printf "Could not determine module directory, please set BITS_MODULEDIR\n"
   exit 1
fi

if [ -w . -a ! -f bits.rc -a  ! -f .bitsrc ]
then
  printf "moduledir=$moduledir\nplatform=$platform\n" > .bitsenv
fi

modules=$moduledir/$platform/Modules

if [  ! -d $modules ]
then
   echo "$modules directory not found"
   exit 1
fi

unset MODULESHOME

function modulepath() {
  local dir
  local colon
  local subdir
  subdir=$1; shift 1
  for dir in $MODULEPATH $*
  do
    if [ -d $dir/Modules/$subdir ]
    then
       printf "${colon}${dir}/Modules/${subdir}"
       colon=":"
    fi
  done
  printf "\n"
}

function test_toolchain() {
  local TMPPREF=/tmp/bitsenv_helloworld
  cat > $TMPPREF.cpp <<EOF
#include <iostream>
int main(int argn, char *argv[]) {
  std::cout << "hello world" << std::endl;
  return 0;
}
EOF
  g++ -o $TMPPREF ${TMPPREF}.cpp > ${TMPPREF}.log 2>&1
  if [[ `/tmp/bitsenv_helloworld 2> /dev/null` != "hello world" ]]; then
    echo "WARNING: We are using GNU C++ compiler at $(which g++ 2> /dev/null)" >&2
    echo "WARNING: This compiler is unable to produce valid executables on this platform!" >&2
    echo "WARNING: Error from g++ follows:" >&2
    while IFS= read LINE; do
      echo "WARNING: $LINE" >&2
    done < <(cat ${TMPPREF}.log)
  else
    echo "NOTICE: loaded compiler ($(which g++)) seems to produce valid executables" >&2
  fi
  rm -f ${TMPPREF}*
}


# Transform a comma-separated packages to modulecmd
# format, i.e.:
#
# Returned list (on stdout) is also sorted: packages with a certain priority
# are moved at the beginning of the list.
function normalize_sort_packages() {
  NORM=( $(echo $1 | sed -e 's%::%/%g' -e 's%,% %g') )
  [[ $BITSENV_DEBUG == 1 ]] && printf "NOTICE: list of packages normalized to ${NORM[*]}\n" >&2
  echo ${NORM[*]}
}

export PATH=$PATH:$path

if [  -d $modules/$version/$distro_dir/$distro_release ]
then
   moduleenv="env LD_LIBRARY_PATH=$modules/$version/$distro_dir/$distro_release/lib"
   modulecmd="$modules/$version/$distro_dir/$distro_release/bin/modulecmd"
else
   moduleenv="env LD_LIBRARY_PATH=$modules/$version/$distro_dir/$distro_xrelease/lib"
   modulecmd="$modules/$version/$distro_dir/$distro_xrelease/bin/modulecmd"
fi

if [[ ! -f $modulecmd ]]; then
  # Fallback on system-installed
  [[ $BITSENV_DEBUG == 1 ]] && printf "NOTICE: using modulecmd from the system\n" >&2
  modulecmd=modulecmd
  moduleenv=
fi

[[ $BITSENV_DEBUG == 1 ]] && printf "modulecmd=$modulecmd\nmoduleenv=$moduleenv\n" >&2

T=`mktemp`

$moduleenv $modulecmd &> $T

if [[ $? == 127 ]]; then
      echo "Unknown distribution release: $distro_name $distro_release"
      [[ $BITSENV_DEBUG == 1 ]] && printf "ERROR: full error message is: `cat $T`\n" >&2
      rm -f $T
      exit 1
fi

rm -f $T
unset T

tclsh <<EOF >/dev/null 2>&1
EOF

[[ $? == 0 ]] && moduleenv=

command=""

# We cannot cross-pick pacakages among different platforms but we have to
# pick all packages consistently from a certain platform tree. When listing
# packages we show them all, when we load a package e define a priority list and
# we always have a fallback for backward compatibility.
ARGS=("$@")
PACKAGES=
EXPECT_PACKAGES=

for ARG in "$@"; do
  if [[ $EXPECT_PACKAGES == 1 ]]; then
    PACKAGES=$(normalize_sort_packages "$ARG")
    break
  elif [[ "$ARG" == enter || "$ARG" == printenv || "$ARG" == setenv || "$ARG" == checkenv ]]; then
    EXPECT_PACKAGES=1
  else
    EXPECT_PACKAGES=
  fi
done

export MODULEPATH="$moduledir/etc/toolchain/modulefiles/$platform:$moduledir/$platform/Modules/modulefiles"

[ x$BITSENV_DEBUG == x1 ] && printf "MODULEPATH=$MODULEPATH\n" >&2

COMMAND_IN_ENV=()

while [ $# -gt 0 ]
do
  case $1 in
     enter)
       shift 1
       args=$(normalize_sort_packages "$1")
       before=`printenv`
       Eval $moduleenv $modulecmd bash load $args 2>/dev/null || exit 1
       after=`printenv | grep -v LS_COLORS=`
       _LM_ENV=""
       for var in $after
       do
         if [[ ! "$before"  =~ "$var" ]]
         then
            _LM_ENV="$var;$_LM_ENV"
         fi
       done
       export _LM_ENV
       exec env PS1="[$args] \W > " bash --norc -i
       ;;
     setenv)
       shift 1
       args=$(normalize_sort_packages "$1")
       Eval $moduleenv $modulecmd bash load $args 2>/dev/null || exit 1
       shift 1
       ;;
     checkenv)
       shift 1
       args=$(normalize_sort_packages "$1")
       Eval $moduleenv $modulecmd bash load $args || exit 1
       PREV_PKG=
       PREV_VER=
       PKG_ERR=
       while read LMF; do
         VER=${LMF##*/}
         PKG=${LMF%/*}
         PKG=${PKG##*/}
         if [[ $PKG == $PREV_PKG && $VER != $PREV_VER ]]; then
           printf "ERROR: attempting to load $PKG $VER when conflicting version $PREV_VER already loaded\n" >&2
           PKG_ERR=1
         fi
         PREV_PKG=$PKG
         PREV_VER=$VER
       done < <(echo $_LMFILES_ | sed -e 's/:/\n/g' | sort)
       [[ $PKG_ERR ]] && exit 1
       [[ $BITSENV_DEBUG == 1 ]] && printf "NOTICE: all packages loaded successfully\n" >&2
       exit 0
       ;;
     printenv)
       shift 1
       if [ x$1 = x ]
       then
          echo $_LM_ENV
       fi
       args=$(normalize_sort_packages "$1")
       $moduleenv $modulecmd bash load $args 2>/dev/null
       exit
       ;;
     -m|-?modules|-?mdir|-?moduledir)
       shift 2
       ;;
     -p|--platform)
       shift 2
       ;;
     -print)
       shift 1
       var=$1
       echo ${!var}
       shift 1
       ;;
     -a|--archive)
       shift 1
       export MODULEPATH=$MODULEPATH:$(modulepath archive $moduledirs)
       ;;
     -c)
       shift; COMMAND_IN_ENV=("$@");
       exec "${COMMAND_IN_ENV[@]}"
       ;;
     -h)
       Help
       ;;
     q|query)
       $moduleenv $modulecmd bash -t avail  2>&1 | grep -v -e : -e "^$"
       exit $?
       ;;
     *)
       $moduleenv $modulecmd bash $*
       exit
     ;;
    esac
done

